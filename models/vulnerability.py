# models/vulnerability.py
import uuid
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class VulnerabilityType(str, Enum):
    INJECTION = "INJECTION"
    SQL_INJECTION = "SQL_INJECTION"
    OS_COMMAND_INJECTION = "OS_COMMAND_INJECTION"
    CODE_INJECTION = "CODE_INJECTION"
    HTTP_METHOD_INJECTION = "HTTP_METHOD_INJECTION"
    CROSS_SITE_SCRIPTING = "CROSS_SITE_SCRIPTING"
    CSRF = "CROSS_SITE_REQUEST_FORGERY_(CSRF)"
    PATH_TRAVERSAL = "PATH_TRAVERSAL"
    INSECURE_DESERIALIZATION = "INSECURE_DESERIALIZATION"
    BROKEN_AUTHENTICATION = "BROKEN_AUTHENTICATION"
    SENSITIVE_DATA_EXPOSURE = "SENSITIVE_DATA_EXPOSURE"
    XML_EXTERNAL_ENTITY = "XML_EXTERNAL_ENTITY"
    BROKEN_ACCESS_CONTROL = "BROKEN_ACCESS_CONTROL"
    SECURITY_MISCONFIGURATION = "SECURITY_MISCONFIGURATION"
    SECURE_RANDOMNESS = "SECURE_RANDOMNESS"
    INSUFFICIENT_LOGGING = "INSUFFICIENT_LOGGING"
    WEAK_CRYPTOGRAPHY = "WEAK_CRYPTOGRAPHY"
    USING_COMPONENTS_WITH_KNOWN_VULNERABILITIES = "USING_COMPONENTS_WITH_KNOWN_VULNERABILITIES"
    BUFFER_OVERFLOW = "BUFFER_OVERFLOW"
    FORMAT_STRING = "FORMAT_STRING"
    INTEGER_OVERFLOW = "INTEGER_OVERFLOW"
    RACE_CONDITION = "RACE_CONDITION"
    HARDCODED_CREDENTIALS = "HARDCODED_CREDENTIALS"
    EXPOSED_SENSITIVE_INFORMATION = "EXPOSED_SENSITIVE_INFORMATION"
    EXPOSED_SECRET = "EXPOSED_SECRET"
    FILE_INCLUSION = "FILE_INCLUSION"
    INSECURE_FILE_READ = "INSECURE_FILE_READ"
    EXPOSED_GITHUB_URL = "EXPOSED_GITHUB_URL"
    IMPROPER_ERROR_HANDLING = "IMPROPER_ERROR_HANDLING"
    DEPENDENCY_VULNERABILITY = "DEPENDENCY_VULNERABILITY"
    INSECURE_IMPORTS = "INSECURE_IMPORTS"
    UNSAFE_PROPERTY_ACCESS = "UNSAFE_PROPERTY_ACCESS"
    POTENTIAL_INSECURE_USE_OF_OPERATOR = "POTENTIAL_INSECURE_USE_OF_OPERATOR"
    TESTING_FLAGS_UNHANDLED = "TESTING_FLAGS_UNHANDLED"
    INSUFFICIENT_INPUT_VALIDATION = "INSUFFICIENT_INPUT_VALIDATION"
    DENIAL_OF_SERVICE = "DENIAL_OF_SERVICE"
    REGULAR_EXPRESSION_DENIAL_OF_SERVICE = "REGULAR_EXPRESSION_DENIAL_OF_SERVICE"
    EXPOSED_FLASK_DEBUG = "EXPOSED_FLASK_DEBUG"
    SERVER_SIDE_REQUEST_FORGERY = "SERVER_SIDE_REQUEST_FORGERY_(SSRF)"
    ENVIRONMENT_VARIABLE_INJECTION = "ENVIRONMENT_VARIABLE_INJECTION"
    INSECURE_RANDOM_SEEDING = "INSECURE_RANDOM_SEEDING"
    USE_OF_WEAK_HASHING_ALGORITHM = "USE_OF_WEAK_HASHING_ALGORITHM"
    UNHANDLED_EXCEPTION = "UNHANDLED_EXCEPTION"
    REMOTE_CODE_EXECUTION = "REMOTE_CODE_EXECUTION_(RCE)"
    INSECURE_DIRECT_OBJECT_REFERENCE = "INSECURE_DIRECT_OBJECT_REFERENCE_(IDOR)"
    MISSING_AUTHENTICATION = "MISSING_AUTHENTICATION"
    EXCESSIVE_DATA_EXPOSURE = "EXCESSIVE_DATA_EXPOSURE"
    INFORMATION_EXPOSURE_THROUGH_QUERY_STRING = "INFORMATION_EXPOSURE_THROUGH_QUERY_STRING"
    FAILURE_TO_RESTRICT_URL_ACCESS = "FAILURE_TO_RESTRICT_URL_ACCESS"
    TYPE_COERCION_VULNERABILITY = "TYPE_COERCION_VULNERABILITY"
    ASSERTION_FAILURE_VULNERABILITY = "ASSERTION_FAILURE_VULNERABILITY"
    PYTHONIC_TYPE_CHECK_VIOLATION = "PYTHONIC_TYPE_CHECK_VIOLATION"
    UNVALIDATED_REDIRECTS_AND_FORWARDED_REQUESTS = "UNVALIDATED_REDIRECTS_AND_FORWARDED_REQUESTS"
    INSECURE_DATA_STORAGE = "INSECURE_DATA_STORAGE"
    EXPOSED_SECURITY_HEADERS = "EXPOSED_SECURITY_HEADERS"
    EXPOSED_ADMIN_FUNCTIONALITIES = "EXPOSED_ADMIN_FUNCTIONALITIES"
    INSECURE_ENVIRONMENT_VARIABLE_USAGE = "INSECURE_ENVIRONMENT_VARIABLE_USAGE"
    INSECURE_HTTP_HEADERS = "INSECURE_HTTP_HEADERS"
    INJECTION_FLAW = "INJECTION_FLAW"
    SECURE_COOKIE = "SECURE_COOKIE"
    INSECURE_CONFIGURATION_SETTING = "INSECURE_CONFIGURATION_SETTING"
    INFORMATION_EXPOSURE_THROUGH_ERROR_MESSAGES = "INFORMATION_EXPOSURE_THROUGH_ERROR_MESSAGES"
    GENERIC_SECURITY_ISSUE = "GENERIC_SECURITY_ISSUE"  # Added fallback type

    def is_related_to(self, other: 'VulnerabilityType') -> bool:
        """
        Define relationships between vulnerability types
        """

        relationships = {
            VulnerabilityType.SQL_INJECTION: [
                VulnerabilityType.SENSITIVE_DATA_EXPOSURE,
                VulnerabilityType.BROKEN_ACCESS_CONTROL
            ],
            VulnerabilityType.CROSS_SITE_SCRIPTING: [
                VulnerabilityType.CSRF,
                VulnerabilityType.SENSITIVE_DATA_EXPOSURE
            ],
            # Add more relationships as needed
        }
        return other in relationships.get(self, [])

class VulnerabilitySeverity(str, Enum):
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"
    INFO = "INFO"

class CodeLocation(BaseModel):
    file_path: str
    start_line: int
    end_line: int
    start_col: Optional[int] = None
    end_col: Optional[int] = None
    context: Optional[str] = None

    def is_connected_to(self, other: 'CodeLocation') -> bool:
        """
        Check if two code locations are connected

        Args:
            other: The other code location

        Returns:
            bool: True if connected, False otherwise
        """

        if self.file_path != other.file_path:
            return False

        # Check if locations are within reasonable proximity
        return abs(self.start_line - other.start_line) <= 10

class Vulnerability(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    type: VulnerabilityType
    severity: VulnerabilitySeverity
    location: CodeLocation
    description: str
    impact: str
    remediation: str
    cwe_id: str
    owasp_category: str
    cvss_score: float
    references: List[str]
    proof_of_concept: str
    secure_code_example: str

class VulnerabilityChain(BaseModel):
    vulnerabilities: List[Vulnerability]
    combined_severity: VulnerabilitySeverity
    attack_path: str
    likelihood: float
    prerequisites: List[str]
    mitigation_priority: int

class VulnerabilityReport(BaseModel):
    timestamp: datetime
    file_name: Optional[str] = None
    repository_url: Optional[str] = None
    branch: Optional[str] = None
    vulnerabilities: List[Vulnerability]
    chained_vulnerabilities: List[VulnerabilityChain]
    summary: Optional[Dict[str, int]] = None
    risk_score: Optional[float] = None

    def calculate_summary(self) -> None:
        """
        Calculate summary statistics for the vulnerabilities
        """

        self.summary = {
            "total": len(self.vulnerabilities),
            "critical": len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL]),
            "high": len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.HIGH]),
            "medium": len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.MEDIUM]),
            "low": len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.LOW]),
            "info": len([v for v in self.vulnerabilities if v.severity == VulnerabilitySeverity.INFO])
        }

    def calculate_risk_score(self) -> None:
        """
        Calculate overall risk score based on vulnerability severity and chains
        """

        severity_weights = {
            VulnerabilitySeverity.CRITICAL: 10,
            VulnerabilitySeverity.HIGH: 8,
            VulnerabilitySeverity.MEDIUM: 5,
            VulnerabilitySeverity.LOW: 2,
            VulnerabilitySeverity.INFO: 1
        }

        base_score = sum(severity_weights[v.severity] for v in self.vulnerabilities)
        chain_multiplier = 1 + (len(self.chained_vulnerabilities) * 0.1)

        self.risk_score = round(base_score * chain_multiplier, 2)